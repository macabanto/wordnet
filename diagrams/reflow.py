#!/usr/bin/env python3
# reflow.py — rearrange an existing draw.io diagram produced by script.py

import sys
import re
from pathlib import Path
import xml.etree.ElementTree as ET
from collections import defaultdict, deque

# ------------ layout knobs (keep in sync with generator) -------------
FILE_W, FILE_H = 180, 60
CELL_W, CELL_H = 180, 40

COL_X_GAP = 280     # gap between file columns
ROW_Y_GAP = 220     # gap between files vertically

VARS_OFFSET  = (0, 100)    # left/below the file box
FUNCS_OFFSET = (220, 0)    # right of the file box
STACK_VGAP   = 66          # vertical spacing for stacked cells

# -------------------------- utils -----------------------------------
def _sanitize(s: str) -> str:
    return re.sub(r'[^A-Za-z0-9]+', '_', s).strip('_')

def is_file_box(cell: ET.Element) -> bool:
    return cell.get('vertex') == '1' and 'shape=parallelogram' in (cell.get('style') or '')

def is_edge(cell: ET.Element) -> bool:
    return cell.get('edge') == '1'

def get_geom(cell: ET.Element):
    g = cell.find('./mxGeometry')
    return g

def set_xy(cell: ET.Element, x: float, y: float):
    g = get_geom(cell)
    if g is not None:
        g.set('x', str(x))
        g.set('y', str(y))

def get_xy(cell: ET.Element):
    g = get_geom(cell)
    if g is None: return (0.0, 0.0)
    return (float(g.get('x') or 0), float(g.get('y') or 0))

# -------------------------- reflow -----------------------------------
def reflow(input_path: Path, output_path: Path):
    tree = ET.parse(str(input_path))
    root = tree.getroot()

    # draw.io cells live under: /mxfile/diagram/mxGraphModel/root/mxCell
    cells_parent = root.find('.//root')
    if cells_parent is None:
        print('[!] could not find <root> container')
        sys.exit(1)

    # index cells
    cells = list(cells_parent.findall('./mxCell'))
    by_id = {c.get('id'): c for c in cells}

    # 1) collect file boxes
    file_cells = []
    for c in cells:
        if is_file_box(c):
            file_cells.append(c)

    if not file_cells:
        print('[!] no file boxes found (parallelograms)')
        sys.exit(1)

    # map: fileId -> label (value)
    file_labels = {c.get('id'): (c.get('value') or '') for c in file_cells}
    # build sanitized key -> fileId
    file_keys = {}
    for c in file_cells:
        lbl = file_labels[c.get('id')]
        key = _sanitize(lbl)
        file_keys[key] = c.get('id')

    # 2) collect file→file edges (only edges where both endpoints are files)
    graph = defaultdict(list)   # id -> [id]
    indeg = defaultdict(int)
    for c in cells:
        if not is_edge(c):
            continue
        src = c.get('source')
        dst = c.get('target')
        if not src or not dst: continue
        if src in file_labels and dst in file_labels:
            graph[src].append(dst)
            indeg[dst] += 1
            indeg.setdefault(src, 0)

    file_ids = [c.get('id') for c in file_cells]
    # ensure all files have indegree key
    for fid in file_ids:
        indeg.setdefault(fid, 0)
        graph.setdefault(fid, [])

    # 3) layer assignment (Kahn topological-ish; cycles collapse to layer 0)
    layers = {fid: 0 for fid in file_ids}
    q = deque([fid for fid in file_ids if indeg[fid] == 0])
    order = []

    indeg_work = dict(indeg)
    while q:
        u = q.popleft()
        order.append(u)
        for v in graph[u]:
            # layer of v at least layer(u)+1
            layers[v] = max(layers[v], layers[u] + 1)
            indeg_work[v] -= 1
            if indeg_work[v] == 0:
                q.append(v)

    # any nodes not processed (cycles) keep their current layer (0)
    # optional: push them to the rightmost layer to avoid overlap
    if order:
        max_layer = max(layers.values())
        for fid in file_ids:
            if fid not in order:
                layers[fid] = max_layer  # shove cyclic group to last column

    # 4) within each layer, sort files by label for stable vertical order
    layer_buckets = defaultdict(list)
    for fid in file_ids:
        layer_buckets[layers[fid]].append(fid)
    for L in layer_buckets:
        layer_buckets[L].sort(key=lambda fid: file_labels[fid])

    # compute new positions for files
    file_pos = {}
    for L in sorted(layer_buckets.keys()):
        for row_idx, fid in enumerate(layer_buckets[L]):
            x = L * COL_X_GAP
            y = row_idx * ROW_Y_GAP
            file_pos[fid] = (x, y)

    # 5) move file boxes
    for fid, (x, y) in file_pos.items():
        set_xy(by_id[fid], x, y)

    # 6) group var/func stacks by file using id prefixes generated by script.py
    #    - file ids were 'file_<sanitized(rel)>_*'
    #    - fn ids start with 'fn_<sanitized(rel)>'
    #    - var ids start with 'var_<sanitized(rel)>'
    file_sanitized = {fid: _sanitize(file_labels[fid]) for fid in file_ids}

    # collect all var/func cells and associate to file by prefix match
    vars_for_file  = defaultdict(list)  # fid -> [cell]
    funcs_for_file = defaultdict(list)

    for c in cells:
        if c.get('vertex') != '1': continue
        cid = c.get('id') or ''
        if cid.startswith('var_') or cid.startswith('fn_'):
            # try to match to a file by sanitized prefix
            matched = None
            for fid, key in file_sanitized.items():
                if cid.startswith('var_'+key) or cid.startswith('fn_'+key):
                    matched = (fid, 'var' if cid.startswith('var_') else 'fn')
                    break
            if matched:
                fid, kind = matched
                if kind == 'var':
                    vars_for_file[fid].append(c)
                else:
                    funcs_for_file[fid].append(c)

    # keep original vertical order (sort by current y) to reduce jumpiness
    for fid in file_ids:
        vars_for_file[fid].sort(key=lambda c: get_xy(c)[1])
        funcs_for_file[fid].sort(key=lambda c: get_xy(c)[1])

    # 7) reposition stacks relative to file box
    for fid in file_ids:
        fx, fy = file_pos[fid]
        # vars stack
        vx0, vy0 = fx + VARS_OFFSET[0], fy + VARS_OFFSET[1]
        for i, c in enumerate(vars_for_file[fid]):
            set_xy(c, vx0, vy0 + i*STACK_VGAP)
        # funcs stack
        fx0, fy0 = fx + FUNCS_OFFSET[0], fy + FUNCS_OFFSET[1]
        for i, c in enumerate(funcs_for_file[fid]):
            set_xy(c, fx0, fy0 + i*STACK_VGAP)

    # 8) write out
    tree.write(output_path, encoding='utf-8', xml_declaration=False)
    print(f"[ok] Reflowed layout → {output_path}")

# -------------------------- CLI -------------------------------------
if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("usage: python3 reflow.py <input.drawio> [output.drawio]")
        sys.exit(1)
    inp = Path(sys.argv[1]).resolve()
    out = Path(sys.argv[2]).resolve() if len(sys.argv) > 2 else inp
    reflow(inp, out)